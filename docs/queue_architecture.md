# Two-Queue Architecture: Internal Bank Queues + Central RTGS Queue

> **Implementation Status**: Queue 2 (RTGS) complete (Phase 3), Queue 1 (Internal) planned (Phase 4)
>
> **Last Updated**: 2025-10-27

## Executive Summary

The payment simulator uses a **two-queue architecture** that mirrors real-world RTGS systems:

1. **Queue 1 (Internal Bank Queues)**: Where cash managers make strategic decisions about **when** to submit payments to RTGS
2. **Queue 2 (Central RTGS Queue)**: Where payments wait for **liquidity** to become available after submission

This separation models the critical distinction between **policy decisions** (Queue 1) and **mechanical settlement** (Queue 2) in real payment systems.

```
Client transaction arrives
         ↓
    [Queue 1] ← Cash manager policy (strategic)
         ↓
    Submit to RTGS
         ↓
    [Queue 2] ← Settlement engine (mechanical)
         ↓
    Settlement complete
```

---

## 1. The Two Queues Explained

### Queue 1: Internal Bank Queues (Per-Agent)

**Purpose**: Strategic holding and release decisions by cash managers

**Location**: `Agent.outgoing_queue: Vec<String>` (transaction IDs)

**Authority**: Cash manager policy (rule-based or AI/RL)

**Entry Conditions**:
- New transaction arrives from client
- Transaction generated by arrival process
- Transaction split into parts (pacing)

**Exit Conditions**:
- Cash manager decides to submit to RTGS
- Transaction split into smaller parts
- Transaction cancelled/dropped

**Key Characteristics**:
- **Per-agent**: Each bank has its own internal queue
- **Policy-driven**: Decisions based on liquidity, urgency, deadlines, counterparty
- **Strategic**: This is where the "game" happens (AI agents learn here)
- **No settlement**: Transactions wait in Queue 1, don't affect balances

**Typical Decision Factors**:
- Available liquidity (balance + credit headroom)
- Transaction deadline urgency
- Expected incoming payments
- Time of day (morning rush, end-of-day settlement)
- Counterparty relationship
- System-wide queue pressure

### Queue 2: Central RTGS Queue (Global)

**Purpose**: Mechanical retry for transactions awaiting liquidity

**Location**: `SimulationState.rtgs_queue: Vec<String>` (transaction IDs)

**Authority**: RTGS settlement engine (deterministic)

**Entry Conditions**:
- Transaction submitted to RTGS by bank
- Immediate settlement fails (insufficient liquidity)
- Specifically: `sender.balance + sender.credit_limit < amount`

**Exit Conditions**:
- Settlement succeeds (liquidity became available)
- LSM resolves via bilateral offsetting or cycle settlement
- Deadline expires (transaction dropped)

**Key Characteristics**:
- **Global**: Single central queue at the central bank
- **Mechanical**: No policy decisions, just liquidity checks
- **FIFO**: Transactions retried in order of arrival
- **Automatic**: Retried every tick without human intervention

**Processing Logic**:
1. Check if sender now has sufficient liquidity
2. If yes: settle immediately (debit sender, credit receiver)
3. If no: remain in queue for next tick
4. If past deadline: drop transaction

---

## 2. Complete Transaction Lifecycle

### Detailed Flow

```
┌─────────────────────────────────────────────────────────────────────┐
│ 1. CLIENT INTERACTION (Bank's Internal Systems)                     │
│    Client X → Bank A: "Send 500k to Client Y at Bank B"            │
│    Bank A debits Client X's account (internal ledger)              │
└──────────────────────────┬──────────────────────────────────────────┘
                           ↓
┌─────────────────────────────────────────────────────────────────────┐
│ 2. QUEUE 1 ENTRY: Internal Bank Queue (Phase 4)                     │
│    Transaction added to Bank A's outgoing queue                     │
│    Status: Pending (in Queue 1)                                     │
│                                                                      │
│    Agent.outgoing_queue.push(tx_id)                                 │
└──────────────────────────┬──────────────────────────────────────────┘
                           ↓
┌─────────────────────────────────────────────────────────────────────┐
│ 3. CASH MANAGER POLICY EVALUATION (Phase 4)                         │
│    Cash manager analyzes:                                           │
│    - Current liquidity: balance + credit_limit                      │
│    - Transaction urgency: deadline - current_tick                   │
│    - Expected inflows: incoming_expected transactions               │
│    - System pressure: RTGS queue size, throughput                   │
│                                                                      │
│    Decision options:                                                │
│    ✓ Submit now → send to Queue 2                                   │
│    ✓ Hold → keep in Queue 1 (wait for better timing)                │
│    ✓ Split → divide into smaller parts (pacing)                     │
│    ✓ Drop → cancel (will expire anyway)                             │
└──────────────────────────┬──────────────────────────────────────────┘
                           ↓
┌─────────────────────────────────────────────────────────────────────┐
│ 4. SUBMISSION TO RTGS (Phase 3 - Implemented)                       │
│    Bank A submits to RTGS: submit_transaction(tx, tick)             │
│    RTGS attempts immediate settlement:                               │
│                                                                      │
│    if sender.can_pay(amount):                                       │
│        sender.debit(amount)                                         │
│        receiver.credit(amount)                                      │
│        tx.settle(amount, tick)                                      │
│        return SettledImmediately                                    │
│    else:                                                            │
│        SimulationState.rtgs_queue.push(tx_id)                       │
│        return Queued                                                │
└──────────────────────────┬──────────────────────────────────────────┘
                           ↓
                  ┌────────┴─────────┐
                  ↓                  ↓
      ┌───────────────────┐   ┌────────────────────┐
      │ 4a. IMMEDIATE      │   │ 4b. QUEUED IN      │
      │     SETTLEMENT     │   │     QUEUE 2        │
      │     (Success)      │   │     (Waiting)      │
      └─────────┬──────────┘   └─────────┬──────────┘
                ↓                         ↓
                ↓           ┌─────────────────────────────────────────┐
                ↓           │ 5. QUEUE 2 PROCESSING (Phase 3)         │
                ↓           │    Each tick: process_queue()           │
                ↓           │    - Retry all queued transactions      │
                ↓           │    - FIFO order                         │
                ↓           │    - Check liquidity again              │
                ↓           │    - Settle if possible                 │
                ↓           │    - Drop if past deadline              │
                ↓           └─────────┬───────────────────────────────┘
                ↓                     ↓
                ↓           ┌─────────────────────────────────────────┐
                ↓           │ 6. LSM OPTIMIZATION (Phase 3)           │
                ↓           │    If queue still has items:            │
                ↓           │    - Bilateral offsetting (A↔B netting) │
                ↓           │    - Cycle detection (A→B→C→A)          │
                ↓           │    - Settle with minimal net liquidity  │
                ↓           └─────────┬───────────────────────────────┘
                ↓                     ↓
                └─────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────────────────┐
│ 7. SETTLEMENT COMPLETE                                               │
│    Bank B receives settlement notice                                 │
│    Bank B credits Client Y's account (internal ledger)              │
│                                                                      │
│    Liquidity recycling: Bank B can now use these funds              │
└─────────────────────────────────────────────────────────────────────┘
```

### Key Observations

1. **Two decision points**:
   - Queue 1: **Strategic** (cash manager policy)
   - Queue 2: **Mechanical** (liquidity availability)

2. **Two waiting periods**:
   - Queue 1: Waiting for **policy decision**
   - Queue 2: Waiting for **liquidity**

3. **Queue 1 enables the "game"**:
   - Banks can strategically delay submissions
   - Coordination failures lead to gridlock
   - AI agents learn optimal timing policies

4. **Queue 2 enables realistic RTGS**:
   - Not all payments settle immediately
   - Liquidity recycling is critical
   - LSM optimization reduces queue sizes

---

## 3. Queue Comparison Table

| Aspect | Queue 1 (Internal) | Queue 2 (Central RTGS) |
|--------|-------------------|------------------------|
| **Location** | `Agent.outgoing_queue` | `SimulationState.rtgs_queue` |
| **Scope** | Per-agent (one per bank) | Global (one central queue) |
| **Purpose** | Strategic timing decisions | Mechanical liquidity retry |
| **Authority** | Cash manager policy | RTGS settlement engine |
| **Entry** | Transaction arrives from client | Submit to RTGS, insufficient liquidity |
| **Exit** | Cash manager submits to RTGS | Settlement succeeds or deadline expires |
| **Processing** | Policy evaluation (event-driven or per-tick) | FIFO retry every tick |
| **Decision Factors** | Liquidity, urgency, deadlines, strategy | Liquidity availability only |
| **Game-Theoretic** | YES - strategic interaction | NO - mechanical operation |
| **Learning Target** | YES - AI agents learn here | NO - fixed algorithm |
| **Implementation Status** | ⏳ Planned (Phase 4) | ✅ Complete (Phase 3) |

---

## 4. Code Examples

### Phase 3 (Current): Direct Submission to Queue 2

```rust
// Current implementation: transactions go directly to RTGS
let agents = vec![
    Agent::new("BANK_A".to_string(), 1_000_000, 500_000),
    Agent::new("BANK_B".to_string(), 0, 0),
];
let mut state = SimulationState::new(agents);

// Transaction created and immediately submitted
let tx = Transaction::new("BANK_A".to_string(), "BANK_B".to_string(), 500_000, 0, 100);
let result = submit_transaction(&mut state, tx, 5);

// Result: Either SettledImmediately or Queued (Queue 2)
match result {
    Ok(SubmissionResult::SettledImmediately { tick }) => {
        println!("Settled at tick {}", tick);
    }
    Ok(SubmissionResult::Queued { position }) => {
        println!("Queued in RTGS (position {})", position);
        // Now in Queue 2, will be retried each tick
    }
    Err(e) => println!("Error: {}", e),
}
```

### Phase 4 (Future): Queue 1 → Queue 2 Flow

```rust
// Future implementation: transactions go to Queue 1 first
let mut state = SimulationState::new(agents);
let mut policies: HashMap<String, Box<dyn CashManagerPolicy>> = HashMap::new();

// Each bank has a policy
policies.insert("BANK_A".to_string(), Box::new(LiquidityAwarePolicy::new(100_000)));

// 1. Transaction arrives → Queue 1
let tx = Transaction::new("BANK_A".to_string(), "BANK_B".to_string(), 500_000, 0, 100);
let tx_id = tx.id().to_string();
state.add_transaction(tx);

let agent = state.get_agent_mut("BANK_A").unwrap();
agent.queue_outgoing(tx_id.clone());  // Add to Queue 1

// 2. Cash manager evaluates Queue 1
let policy = policies.get_mut("BANK_A").unwrap();
let agent = state.get_agent("BANK_A").unwrap();
let decisions = policy.evaluate_queue(agent, &state, 5);

// 3. Process decisions
for decision in decisions {
    match decision {
        ReleaseDecision::SubmitFull { tx_id } => {
            // Move from Queue 1 to Queue 2
            let agent = state.get_agent_mut("BANK_A").unwrap();
            agent.remove_from_queue(&tx_id);

            let tx = state.get_transaction(&tx_id).unwrap().clone();
            submit_transaction(&mut state, tx, 5)?;
            // Now in Queue 2 (if insufficient liquidity)
        }
        ReleaseDecision::Hold { tx_id, reason } => {
            // Stay in Queue 1
            println!("Holding {} due to {:?}", tx_id, reason);
        }
        _ => {}
    }
}
```

### Policy Implementation Example

```rust
pub struct LiquidityAwarePolicy {
    target_buffer: i64,
}

impl CashManagerPolicy for LiquidityAwarePolicy {
    fn evaluate_queue(
        &mut self,
        agent: &Agent,
        state: &SimulationState,
        tick: usize,
    ) -> Vec<ReleaseDecision> {
        let mut decisions = Vec::new();

        for tx_id in agent.outgoing_queue() {
            let tx = state.get_transaction(tx_id).unwrap();
            let amount = tx.remaining_amount();

            // Decision logic
            if agent.balance() - amount >= self.target_buffer {
                // Safe to send: won't violate buffer
                decisions.push(ReleaseDecision::SubmitFull {
                    tx_id: tx_id.to_string(),
                });
            } else if tx.is_past_deadline(tick + 5) {
                // Deadline approaching: send anyway
                decisions.push(ReleaseDecision::SubmitFull {
                    tx_id: tx_id.to_string(),
                });
            } else {
                // Hold: preserve liquidity buffer
                decisions.push(ReleaseDecision::Hold {
                    tx_id: tx_id.to_string(),
                    reason: HoldReason::InsufficientLiquidity,
                });
            }
        }

        decisions
    }
}
```

---

## 5. Game-Theoretic Implications

### Queue 1 Creates Strategic Interaction

**The "Stag Hunt" Scenario**:
- All banks have payments ready (in Queue 1)
- If all send early: liquidity recycles, everyone settles quickly
- If all wait: gridlock forms, costs mount
- Individual incentive: wait for inflows to reduce credit usage
- Collective benefit: send early for faster throughput

**Queue 1 enables this game**:
- Without Queue 1: transactions auto-submit (no strategy)
- With Queue 1: banks choose timing → strategic interaction

### Queue 2 Enables Liquidity Recycling

**Mechanical Benefit**:
- Bank A pays Bank B (B's balance increases)
- Bank B can immediately pay Bank C (using recycled funds)
- Without Queue 2: failed payments are lost
- With Queue 2: payments retry automatically, enabling chains

**LSM Amplifies This**:
- Bilateral offsetting: A↔B nets to smaller flow
- Cycle settlement: A→B→C→A resolves with zero net liquidity
- Queue 2 is where LSM operates

---

## 6. Implementation Architecture

### Data Flow

```
Arrival → Agent.outgoing_queue (Queue 1)
            ↓ (policy decision)
          submit_transaction()
            ↓
          try_settle()
          ↓         ↓
     [Success]  [Fail: insufficient liquidity]
          ↓         ↓
      Settled    SimulationState.rtgs_queue (Queue 2)
                    ↓ (each tick)
                process_queue()
                    ↓         ↓
               [Success]  [Still queued]
                    ↓         ↓
                Settled    run_lsm_pass()
                              ↓
                          [Optimize]
                              ↓
                           Settled
```

### Module Ownership

| Module | Owns Queue 1 | Owns Queue 2 | Decision Authority |
|--------|--------------|--------------|-------------------|
| `models/agent.rs` | YES | NO | Queue 1 additions (fields, methods) |
| `models/state.rs` | NO | YES | Queue 2 implemented |
| `policy/` | NO | NO | Queue 1 policy evaluation |
| `settlement/rtgs.rs` | NO | YES | Queue 2 processing |
| `settlement/lsm.rs` | NO | YES | Queue 2 optimization |
| `orchestrator/engine.rs` | NO | NO | Coordinates Queue 1 → Queue 2 |

---

## 7. Testing Strategy

### Queue 1 Tests (Phase 4)

**Unit tests** (`backend/tests/test_agent.rs`):
```rust
#[test]
fn test_queue_outgoing_transaction() {
    let mut agent = Agent::new("BANK_A".to_string(), 1_000_000, 0);
    agent.queue_outgoing("tx_001".to_string());

    assert_eq!(agent.outgoing_queue_size(), 1);
    assert_eq!(agent.outgoing_queue()[0], "tx_001");
}

#[test]
fn test_policy_holds_when_insufficient_liquidity() {
    // Test that LiquidityAwarePolicy holds transactions
    // when balance - amount < target_buffer
}
```

**Integration tests** (`backend/tests/test_queue_flow.rs`):
```rust
#[test]
fn test_queue_1_to_queue_2_flow() {
    // 1. Add transaction to Queue 1
    // 2. Policy evaluates and submits
    // 3. Transaction moves to Queue 2 (if insufficient liquidity)
    // 4. Verify Queue 1 empty, Queue 2 has transaction
}

#[test]
fn test_policy_comparison() {
    // Run same scenario with FifoPolicy vs LiquidityAwarePolicy
    // Verify different queue behaviors
    // Compare: settlement times, credit usage, queue sizes
}
```

### Queue 2 Tests (Phase 3 - Already Implemented)

**22 passing tests** in `backend/tests/test_rtgs_settlement.rs`:
- Immediate settlement
- Queue processing (FIFO, deadline expiration)
- Liquidity recycling
- Gridlock scenarios
- Balance conservation

---

## 8. Migration Path: Phase 3 → Phase 4

### Phase 3 (Current): Queue 2 Only

**Transaction submission is direct**:
```rust
// Transaction created
let tx = Transaction::new(...);

// Immediately submitted to RTGS (Queue 2 entry)
submit_transaction(&mut state, tx, tick);
```

**This works for**:
- Testing RTGS settlement logic
- Validating LSM algorithms
- Proving balance conservation

**But missing**:
- Strategic timing decisions
- Cash manager policy evaluation
- Game-theoretic interaction

### Phase 4 (Future): Queue 1 + Queue 2

**Transaction submission is two-stage**:
```rust
// 1. Transaction created → Queue 1
let tx = Transaction::new(...);
state.add_transaction(tx);
agent.queue_outgoing(tx.id());

// 2. Policy decides when to submit → Queue 2
let decisions = policy.evaluate_queue(agent, &state, tick);
for decision in decisions {
    if let ReleaseDecision::SubmitFull { tx_id } = decision {
        let tx = state.remove_from_agent_queue(&agent_id, &tx_id);
        submit_transaction(&mut state, tx, tick);
    }
}
```

**Backward compatibility**:
- Phase 3 tests still work (submit_transaction() unchanged)
- Can add "immediate submission" policy for Phase 3 behavior
- No breaking changes to RTGS/LSM modules

---

## 9. Performance Considerations

### Queue 1 Overhead

**Per-tick cost**:
- Iterate over each agent's outgoing queue: O(A × Q₁) where A = agents, Q₁ = avg queue size
- Policy evaluation: depends on policy complexity
- Typical: O(1) per transaction for simple policies, O(Q₁) for sorting-based policies

**Optimization strategies**:
- Event-driven evaluation (only evaluate on arrivals/settlements)
- Batch evaluation (process multiple transactions together)
- Priority indexing (maintain sorted queue for deadline policies)

### Queue 2 Processing (Already Optimized)

**Per-tick cost**:
- FIFO retry: O(Q₂) where Q₂ = queue size
- LSM bilateral: O(A²) agent pairs
- LSM cycles: O(A³) for 3-cycles
- Typical: Fast for Q₂ < 1000, A < 50

---

## 10. Future Extensions (Phase 5+)

### Advanced Queue 1 Features

**Timed submissions**:
- Schedule transactions for specific future ticks
- "Send at 14:00" instead of "send now"

**Split transactions** (pacing):
- Divide large payments into smaller parts
- Submit incrementally to reduce liquidity requirements

**Priority queues**:
- High-priority transactions bypass policy holds
- Urgent payments (same-day value) skip Queue 1

**Bilateral coordination**:
- Banks signal intended submissions
- Coordinate timing to reduce gridlock

### Advanced Queue 2 Features

**Priority-based processing**:
- High-priority transactions settle first (not FIFO)
- T2-style priority levels

**Reservation systems**:
- Reserve liquidity for specific transactions
- Block liquidity until transaction arrives

**Liquidity pooling**:
- Multiple banks share liquidity
- CLM (Continuous Linked Settlement) style

---

## 11. Alignment with Game Design Doc

### Coverage Verification

| Game Design Requirement | Queue 1 | Queue 2 | Status |
|------------------------|---------|---------|--------|
| "Banks decide when to submit to RTGS" | ✓ | - | Phase 4 |
| "Internal queue of outgoing orders" | ✓ | - | Phase 4 |
| "Release policy: choose share from queue" | ✓ | - | Phase 4 |
| "Immediate settlement if liquidity sufficient" | - | ✓ | Phase 3 ✅ |
| "Else queue in central RTGS" | - | ✓ | Phase 3 ✅ |
| "LSM/optimization tries offsetting and cycles" | - | ✓ | Phase 3 ✅ |
| "Per-tick queue retry" | - | ✓ | Phase 3 ✅ |
| "Deadline-based dropping" | - | ✓ | Phase 3 ✅ |

**Conclusion**: Phase 3 implemented Queue 2 (complete). Phase 4 will add Queue 1 to match full game design.

---

## 12. References

### Internal Documentation
- [Game Concept Doc](./game_concept_doc.md) - Section 3.1 (Payment lifecycle), Section 4.2 (Bank state), Section 5.1 (Action space)
- [Phase 3 RTGS Analysis](./phase3_rtgs_analysis.md) - Queue 2 implementation plan
- [Grand Plan](./grand_plan.md) - Overall architecture

### Code Locations
- Queue 2 implementation: `backend/src/settlement/rtgs.rs`, `backend/src/settlement/lsm.rs`
- Queue 2 state: `backend/src/models/state.rs` (`rtgs_queue` field)
- Queue 1 (planned): `backend/src/models/agent.rs` (commented fields)
- Queue 1 policies (planned): `backend/src/policy/` (to be created)

### External References
- European Central Bank (ECB): TARGET2 documentation
- Sveriges Riksbank: RIX-RTGS system design
- Academic: RTGS simulation studies (Bech & Garratt, IMF Working Papers)

---

*Last updated: 2025-10-27*
*Author: Payment Simulator Development Team*
*Status: Queue 2 implemented (Phase 3 ✅), Queue 1 planned (Phase 4 ⏳)*
