# Replay Identity Fix Strategy

**Date:** 2025-11-15
**Status:** Implementation Plan
**Priority:** CRITICAL

## Executive Summary

The replay system is fundamentally broken due to confusing **tick-range filtering** (which ticks to display) with **simulation context** (overall simulation statistics). This document provides a holistic fix strategy to restore replay identity.

## Root Cause Analysis

### 1. Confusion Between Display Range and Simulation Context

**Problem:** Replay command conflates two distinct concepts:
- **Display filtering**: Which ticks to show verbose output for (`--from-tick`, `--to-tick`)
- **Simulation statistics**: Overall simulation metrics (should always be full simulation)

**Evidence:**
```python
# replay.py lines 1280, 1287-1290
"ticks_executed": ticks_replayed  # WRONG: Should be total_ticks
"total_arrivals": tick_count_arrivals  # WRONG: Should be full simulation arrivals
"total_settlements": tick_count_settlements  # WRONG: Should be full simulation settlements
```

When replaying tick 299 only, JSON shows:
- `ticks_executed: 1` instead of `300`
- `total_arrivals: 6` instead of `549`
- `total_settlements: 15` instead of `439`

**Result:** Nonsensical statistics (250% settlement rate, -9 unsettled transactions)

### 2. Queue2 Not Calculated in Replay

**Problem:** Queue2 size is hardcoded to 0 in replay (line 1137)

**Evidence:**
```python
# replay.py line 1137
"queue2_size": 0,  # Not tracked
```

**Correct calculation** (from strategies.py lines 141-146):
```python
queue2_size = sum(
    1
    for tx_id in rtgs_queue
    if orch.get_transaction_details(tx_id)
    and orch.get_transaction_details(tx_id).get("sender_id") == agent_id
)
```

**Result:** Run shows Queue 2 with 16/15 transactions, replay shows 0

### 3. Overdue Transaction Calculation Differences

**Problem:** Overdue delay costs calculated differently between run and replay

**Evidence:**
- Run: TX 486c46c0 overdue 58 ticks, delay cost $231.78
- Replay: TX 486c46c0 overdue 57 ticks, delay cost $14,250.00

**Root cause:** DatabaseStateProvider.get_overdue_transactions() (line 361) uses simplified estimation:
```python
"estimated_delay_cost": event.get("deadline_penalty_cost", 0) // 10 * ticks_overdue,
```

This doesn't match actual Rust cost calculation logic.

### 4. Missing Event Types in Replay Display

**Problem:** Some event types are not being displayed in replay

**Missing events:**
1. "Transaction Went Overdue" standalone messages
2. "Costs Accrued This Tick" summary block
3. "ðŸ“‹ queued in RTGS" block

**Root cause:** These are generated by display logic that queries live orchestrator state, not from events table.

### 5. Internal Inconsistencies Even in Run Mode

**Problem:** Run mode itself has inconsistencies:
- Header: "âœ… 15 transaction(s) settled:"
- Summary: "Summary: 6 in | **10** settled | 3 LSM | 79 queued"

**Root cause:** Different counting logic for header vs summary line.

---

## Architectural Fix Strategy

### Phase 1: Separate Display Range from Simulation Statistics

**Principle:** Replay should ALWAYS output full simulation statistics in JSON, regardless of `--from-tick`/`--to-tick` range.

**Changes:**

#### 1.1 Fix JSON Output to Show Full Simulation Stats

```python
# replay.py - BEFORE (lines 1276-1290)
output_data = {
    "simulation": {
        "ticks_executed": ticks_replayed,  # WRONG
        ...
    },
    "metrics": {
        "total_arrivals": tick_count_arrivals,  # WRONG
        "total_settlements": tick_count_settlements,  # WRONG
        ...
    },
}

# AFTER
output_data = {
    "simulation": {
        "ticks_executed": summary["ticks_per_day"] * summary["num_days"],  # Full simulation
        "ticks_replayed": ticks_replayed,  # Add new field for clarity
        "replay_range": f"{from_tick}-{end_tick}",
        ...
    },
    "metrics": {
        # Use authoritative stats from simulations table (already persisted by run)
        "total_arrivals": summary["total_arrivals"],
        "total_settlements": summary["total_settlements"],
        "total_lsm_releases": summary.get("total_lsm_releases", tick_count_lsm),
        "settlement_rate": round(summary["total_settlements"] / summary["total_arrivals"], 4),
    },
}
```

**Impact:** JSON output will match run output exactly.

#### 1.2 Add Replay Metadata to Distinguish From Run

```python
output_data["replay_metadata"] = {
    "is_replay": True,
    "from_tick": from_tick,
    "to_tick": end_tick,
    "verbose_ticks_shown": ticks_replayed,
}
```

### Phase 2: Fix Queue2 Calculation

**Principle:** Replay must calculate Queue2 the same way as run mode.

**Changes:**

#### 2.1 Add get_queue2_size Method to DatabaseStateProvider

```python
# state_provider.py - Add to StateProvider protocol
def get_queue2_size(self, agent_id: str) -> int:
    """Get size of agent's RTGS queue (Queue 2)."""
    ...

# OrchestratorStateProvider implementation
def get_queue2_size(self, agent_id: str) -> int:
    """Calculate from RTGS queue."""
    rtgs_queue = self.orch.get_rtgs_queue_contents()
    return sum(
        1
        for tx_id in rtgs_queue
        if self.orch.get_transaction_details(tx_id)
        and self.orch.get_transaction_details(tx_id).get("sender_id") == agent_id
    )

# DatabaseStateProvider implementation
def get_queue2_size(self, agent_id: str) -> int:
    """Calculate from queue snapshots."""
    rtgs_queue = self.get_rtgs_queue_contents()
    return sum(
        1
        for tx_id in rtgs_queue
        if self.get_transaction_details(tx_id)
        and self.get_transaction_details(tx_id).get("sender_id") == agent_id
    )
```

#### 2.2 Use StateProvider in EOD Display

```python
# replay.py line 1137 - BEFORE
"queue2_size": 0,  # Not tracked

# AFTER
"queue2_size": provider.get_queue2_size(agent_id),
```

**Impact:** Queue2 sizes will match between run and replay.

### Phase 3: Fix Overdue Transaction Cost Calculations

**Principle:** Replay must show exact costs from events, not estimate them.

**Changes:**

#### 3.1 Persist Full Overdue Cost Data in Events

Verify that `TransactionWentOverdue` events include all cost fields:
- `deadline_penalty_cost`
- `estimated_delay_cost` (current tick's delay cost)
- `ticks_overdue`

#### 3.2 Add OverdueCostUpdate Event Type

When overdue costs accrue each tick, emit:
```rust
Event::OverdueCostUpdate {
    tick,
    tx_id,
    ticks_overdue,
    current_delay_cost,
    cumulative_delay_cost,
    total_cost,  // deadline_penalty + cumulative_delay_cost
}
```

#### 3.3 Reconstruct Overdue Costs from Events

```python
def get_overdue_transactions(self) -> list[dict]:
    """Get overdue transactions with exact costs from events."""
    # Query TransactionWentOverdue events
    overdue_events = get_simulation_events(
        conn=self.conn,
        simulation_id=self.simulation_id,
        event_type="TransactionWentOverdue",
        tick_max=self.tick,
    )

    # Query latest OverdueCostUpdate for each overdue transaction
    cost_updates = get_simulation_events(
        conn=self.conn,
        simulation_id=self.simulation_id,
        event_type="OverdueCostUpdate",
        tick=self.tick,
    )

    # Merge data...
```

**Impact:** Overdue costs will match exactly between run and replay.

### Phase 4: Add Missing Event Types

**Principle:** All display elements must be driven by events, not by querying live state.

**Changes:**

#### 4.1 Emit TransactionQueuedInRTGS Event

```rust
// In RTGS settlement logic
if !can_settle && !already_in_rtgs {
    self.events.push(Event::TransactionQueuedInRTGS {
        tick: self.current_tick,
        tx_id: tx.id.clone(),
        agent_id: tx.sender_id.clone(),
        reason: "insufficient_balance",
        balance,
        required,
    });
}
```

#### 4.2 Emit CostAccrualSummary Event at End of Tick

```rust
// At end of tick, after all cost accruals
for (agent_id, costs) in tick_cost_accruals {
    self.events.push(Event::CostAccrualSummary {
        tick: self.current_tick,
        agent_id: agent_id.clone(),
        liquidity_cost: costs.liquidity,
        delay_cost: costs.delay,
        collateral_cost: costs.collateral,
        penalty_cost: costs.penalty,
        split_friction_cost: costs.split_friction,
        total_cost: costs.total(),
    });
}
```

#### 4.3 Display These Events in Replay

```python
# replay.py - Add to event reconstruction
if event_type == "TransactionQueuedInRTGS":
    queued_events.append(event)

if event_type == "CostAccrualSummary":
    cost_summary_events.append(event)

# Display queued events
if queued_events:
    log_rtgs_queue_additions(queued_events)

# Display cost summary
if cost_summary_events:
    log_tick_cost_summary(cost_summary_events)
```

**Impact:** Replay will show all the same information as run.

### Phase 5: Fix Internal Inconsistencies in Run Mode

**Principle:** Settlement counts must be consistent across all display elements.

**Changes:**

#### 5.1 Unify Settlement Counting Logic

Create single source of truth function:
```python
def count_settlements(events: list[dict]) -> int:
    """Count total transactions settled from event list.

    Includes:
    - Direct Settlement events (1 transaction each)
    - LSM bilateral offsets (2 transactions each)
    - LSM cycle settlements (len(tx_ids) transactions each)
    """
    count = 0
    for event in events:
        if event["event_type"] == "Settlement":
            count += 1
        elif event["event_type"] == "LsmBilateralOffset":
            count += len(event.get("tx_ids", []))
        elif event["event_type"] == "LsmCycleSettlement":
            count += len(event.get("tx_ids", []))
    return count
```

#### 5.2 Use in Both Header and Summary

```python
# In display logic
num_settlements = count_settlements(events)
log_settlement_details(settlement_events, lsm_events)  # Header uses num_settlements
log_tick_summary(..., num_settlements=num_settlements)  # Summary uses same value
```

**Impact:** No more "15 settled" vs "10 settled" contradictions.

---

## Implementation Plan

### Step 1: Write Comprehensive Failing Tests

Create `test_replay_identity_comprehensive.py` with tests for each discrepancy:

```python
def test_replay_shows_full_simulation_statistics():
    """Replay JSON must show full simulation stats, not just replayed tick range."""
    # Run full simulation
    run_output = run_simulation(config, ticks=300)

    # Replay single tick
    replay_output = replay_simulation(sim_id, from_tick=299, to_tick=299)

    # Statistics must match
    assert replay_output["metrics"]["total_arrivals"] == run_output["metrics"]["total_arrivals"]
    assert replay_output["metrics"]["total_settlements"] == run_output["metrics"]["total_settlements"]
    assert replay_output["metrics"]["settlement_rate"] == run_output["metrics"]["settlement_rate"]

def test_replay_calculates_queue2():
    """Replay must calculate Queue2 size correctly."""
    # ... test that queue2_size matches between run and replay

def test_replay_overdue_costs_match():
    """Overdue transaction costs must match between run and replay."""
    # ... test exact cost values match

def test_replay_shows_all_event_types():
    """Replay must show same events as run (queued in RTGS, cost summaries, etc.)."""
    # ... test all event types present

def test_settlement_count_consistency():
    """Settlement count must be consistent in header and summary."""
    # ... test run mode doesn't contradict itself
```

### Step 2: Implement Fixes in Order

1. **Phase 1** (Easiest, highest impact):
   - Fix JSON statistics to use authoritative summary table
   - Immediate improvement to metrics accuracy

2. **Phase 2** (Medium, isolated):
   - Add get_queue2_size() to StateProvider
   - Calculate queue2 in replay

3. **Phase 5** (Medium, improves run mode):
   - Unify settlement counting logic
   - Fixes internal inconsistencies

4. **Phase 4** (Complex, new events):
   - Add TransactionQueuedInRTGS event
   - Add CostAccrualSummary event
   - Display in replay

5. **Phase 3** (Most complex, requires Rust changes):
   - Add OverdueCostUpdate event
   - Fix overdue cost calculations

### Step 3: Validate Replay Identity

Run comprehensive validation:
```bash
# Full replay identity test
uv run payment-sim run --config advanced_policy_crisis.yaml --persist --full-replay --verbose > run.txt
uv run payment-sim replay --simulation-id <id> --verbose > replay.txt

# Compare (should be identical modulo timing)
diff <(grep -v "Duration:\|ticks/s" run.txt) <(grep -v "Duration:\|ticks/s" replay.txt)
# EXIT CODE 0 = SUCCESS
```

### Step 4: Add Regression Protection

Add to CI/CD:
```yaml
# .github/workflows/test.yml
- name: Replay Identity Test
  run: |
    uv run pytest api/tests/integration/test_replay_identity_comprehensive.py -v
```

---

## Success Criteria

- [ ] Replay JSON statistics match run JSON statistics exactly
- [ ] Queue2 sizes match between run and replay
- [ ] Overdue transaction costs match exactly
- [ ] All event types displayed in both run and replay
- [ ] No internal inconsistencies in settlement counts
- [ ] Byte-for-byte replay identity (modulo timing lines)
- [ ] All tests pass
- [ ] CI/CD enforces replay identity

---

## Migration Path

For existing databases without new events:
1. Replay will show warning: "Some events not available (database created before vX.Y.Z)"
2. Replay will use fallback logic where possible
3. For full replay identity, re-run simulation with new version

---

## References

- **Discrepancy Catalog:** `docs/plans/breaking_replay_identity.md`
- **Architecture Doc:** `CLAUDE.md` - Replay Identity section
- **Replay Implementation:** `api/payment_simulator/cli/commands/replay.py`
- **StateProvider Protocol:** `api/payment_simulator/cli/execution/state_provider.py`
- **Run Execution:** `api/payment_simulator/cli/execution/strategies.py`

---

**Next Action:** Begin implementation with Step 1 (write failing tests).
