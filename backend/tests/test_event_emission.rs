//! Integration tests for event emission during simulation
//!
//! This test suite follows strict TDD principles to verify that all simulation
//! events are properly emitted and logged during the orchestrator tick loop.
//!
//! Events tested:
//! - Arrival: Transaction arrivals (automatic generation only - manual injection doesn't log arrivals)
//! - PolicySubmit: Policy decides to submit transaction
//! - PolicyHold: Policy decides to hold transaction
//! - PolicyDrop: Policy decides to drop transaction
//! - PolicySplit: Policy splits transaction into children
//! - Settlement: Transaction settled via RTGS
//! - QueuedRtgs: Transaction queued (insufficient liquidity)
//! - CollateralPost: Agent posts collateral
//! - CollateralWithdraw: Agent withdraws collateral
//! - LsmBilateralOffset: LSM bilateral offset (TODO)
//! - LsmCycleSettlement: LSM cycle detection (TODO)
//! - CostAccrual: Costs accrued
//! - EndOfDay: End-of-day processing
//!
//! ## Important Note on Manual Transaction Injection
//!
//! Manually injecting transactions via `add_transaction()` + `queue_outgoing()`
//! does NOT trigger arrival events. Arrival events are only logged when transactions
//! are generated by the ArrivalGenerator during the tick loop. This is correct behavior -
//! manual injection is for testing, not real simulation arrivals.

use payment_simulator_core_rs::{
    arrivals::{AmountDistribution, ArrivalConfig},
    orchestrator::{AgentConfig, CostRates, Orchestrator, OrchestratorConfig, PolicyConfig},
    settlement::lsm::LsmConfig,
    Transaction,
};
use std::collections::HashMap;

/// Helper function to create a basic 2-agent configuration for testing
fn create_test_config() -> OrchestratorConfig {
    OrchestratorConfig {
        ticks_per_day: 100,
        eod_rush_threshold: 0.8,
        num_days: 1,
        rng_seed: 42,
        agent_configs: vec![
            AgentConfig {
                id: "BANK_A".to_string(),
                opening_balance: 1_000_000, // $10,000
                unsecured_cap: 500_000,      // $5,000
                policy: PolicyConfig::Fifo,
                arrival_config: None,
                posted_collateral: None,
                collateral_haircut: None,
            },
            AgentConfig {
                id: "BANK_B".to_string(),
                opening_balance: 2_000_000, // $20,000
                unsecured_cap: 0,
                policy: PolicyConfig::LiquidityAware {
                    target_buffer: 500_000, // $5,000 buffer
                    urgency_threshold: 5,
                },
                arrival_config: None,
                posted_collateral: None,
                collateral_haircut: None,
            },
        ],
        cost_rates: CostRates::default(),
        lsm_config: LsmConfig::default(),
        scenario_events: None,
    }
}

// ============================================================================
// Test 1: PolicySubmit Events (Manual Transaction)
// ============================================================================
// Note: Manually injected transactions do NOT get arrival events, only lifecycle events

#[test]
fn test_policy_and_settlement_events_for_manual_transaction() {
    // ARRANGE: Create orchestrator with no automatic arrivals and FIFO policy
    let mut orchestrator = Orchestrator::new(create_test_config()).unwrap();

    // Manually create and inject a transaction
    let tx = Transaction::new(
        "BANK_A".to_string(),
        "BANK_B".to_string(),
        100_000, // $1,000
        0,       // arrival tick
        10,      // deadline tick
    );
    let tx_id = tx.id().to_string();

    // Add transaction to state and Queue 1
    orchestrator.state_mut().add_transaction(tx);
    orchestrator
        .state_mut()
        .get_agent_mut("BANK_A")
        .unwrap()
        .queue_outgoing(tx_id.clone());

    // ACT: Execute one tick
    let _result = orchestrator.tick().unwrap();

    // ASSERT: Manual transactions don't get arrival events, but they DO get lifecycle events
    let event_log = orchestrator.event_log();

    // Should have PolicySubmit event (FIFO submits immediately)
    let submit_events = event_log.events_of_type("PolicySubmit");
    assert!(
        !submit_events.is_empty(),
        "Expected PolicySubmit event for manual transaction"
    );

    // Should have Settlement event (sufficient liquidity)
    let settlement_events = event_log.events_of_type("Settlement");
    assert!(
        !settlement_events.is_empty(),
        "Expected Settlement event for manual transaction"
    );

    // Verify the transaction ID is in the events
    let tx_events = event_log.events_for_tx(&tx_id);
    assert!(
        tx_events.len() >= 2,
        "Manual transaction should have at least PolicySubmit + Settlement events"
    );
}

// ============================================================================
// Test 2: Arrival Events (Automatic Generation)
// ============================================================================

#[test]
fn test_arrival_events_for_automatic_transactions() {
    // ARRANGE: Create orchestrator with automatic arrivals
    let mut config = create_test_config();
    config.agent_configs[0].arrival_config = Some(ArrivalConfig {
        rate_per_tick: 0.5, // Expected 0.5 transactions per tick
        amount_distribution: AmountDistribution::Uniform {
            min: 50_000,
            max: 150_000,
        },
        counterparty_weights: {
            let mut weights = HashMap::new();
            weights.insert("BANK_B".to_string(), 1.0);
            weights
        },
        deadline_range: (10, 50),
        priority: 5,
        divisible: true,
    });

    let mut orchestrator = Orchestrator::new(config).unwrap();

    // ACT: Execute 10 ticks to generate some arrivals
    for _ in 0..10 {
        orchestrator.tick().unwrap();
    }

    // ASSERT: Verify arrival events were logged
    let event_log = orchestrator.event_log();
    let arrival_events = event_log.events_of_type("Arrival");

    // With rate 0.5 over 10 ticks, we expect some arrivals (probabilistic)
    // Due to randomness, we can't guarantee exact count, but should have at least one
    assert!(
        !arrival_events.is_empty(),
        "Expected at least one arrival event with automatic generation"
    );

    // Verify all arrival events have correct structure
    for event in arrival_events {
        if let payment_simulator_core_rs::models::Event::Arrival {
            tick,
            sender_id,
            receiver_id,
            amount,
            deadline,
            ..
        } = event
        {
            assert!(*tick < 10, "Event tick should be < 10");
            assert_eq!(sender_id, "BANK_A");
            assert_eq!(receiver_id, "BANK_B");
            assert!(
                *amount >= 50_000 && *amount <= 150_000,
                "Amount should be in range"
            );
            assert!(*deadline >= 10, "Deadline should be at least 10");
        }
    }
}

// ============================================================================
// Test 3: PolicySubmit Events
// ============================================================================

#[test]
fn test_policy_submit_event() {
    // ARRANGE: Create orchestrator with FIFO policy (submits immediately)
    let mut orchestrator = Orchestrator::new(create_test_config()).unwrap();

    // Manually add transaction
    let tx = Transaction::new(
        "BANK_A".to_string(),
        "BANK_B".to_string(),
        100_000,
        0,
        10,
    );
    let tx_id = tx.id().to_string();

    orchestrator.state_mut().add_transaction(tx);
    orchestrator
        .state_mut()
        .get_agent_mut("BANK_A")
        .unwrap()
        .queue_outgoing(tx_id.clone());

    // ACT: Execute tick (FIFO should submit immediately)
    orchestrator.tick().unwrap();

    // ASSERT: Verify PolicySubmit event was logged
    let event_log = orchestrator.event_log();
    let submit_events = event_log.events_of_type("PolicySubmit");

    assert!(
        !submit_events.is_empty(),
        "Expected PolicySubmit event for FIFO policy"
    );

    // Verify event details
    let submit_event = submit_events
        .iter()
        .find(|e| {
            if let payment_simulator_core_rs::models::Event::PolicySubmit {
                tx_id: event_tx_id,
                ..
            } = e
            {
                event_tx_id == &tx_id
            } else {
                false
            }
        })
        .expect("Should find PolicySubmit event");

    if let payment_simulator_core_rs::models::Event::PolicySubmit {
        tick,
        agent_id,
        tx_id: event_tx_id,
    } = submit_event
    {
        assert_eq!(*tick, 0);
        assert_eq!(agent_id, "BANK_A");
        assert_eq!(event_tx_id, &tx_id);
    }
}

// ============================================================================
// Test 4: PolicyHold Events
// ============================================================================

#[test]
fn test_policy_hold_event() {
    // ARRANGE: Create orchestrator with LiquidityAware policy that will hold
    let mut config = create_test_config();
    config.agent_configs[0].opening_balance = 100_000; // $1,000 balance
    config.agent_configs[0].unsecured_cap = 0; // No credit available
    config.agent_configs[0].policy = PolicyConfig::LiquidityAware {
        target_buffer: 90_000, // Want to keep $900 buffer
        urgency_threshold: 50, // Won't consider urgent until 50 ticks before deadline
    };

    let mut orchestrator = Orchestrator::new(config).unwrap();

    // Add transaction that would drop balance below target buffer
    let tx = Transaction::new(
        "BANK_A".to_string(),
        "BANK_B".to_string(),
        50_000, // $500 - would leave only $500 balance, below $900 target
        0,
        100, // Deadline far away, so not urgent
    );
    let tx_id = tx.id().to_string();

    orchestrator.state_mut().add_transaction(tx);
    orchestrator
        .state_mut()
        .get_agent_mut("BANK_A")
        .unwrap()
        .queue_outgoing(tx_id.clone());

    // ACT: Execute tick
    orchestrator.tick().unwrap();

    // ASSERT: Verify PolicyHold event was logged
    let event_log = orchestrator.event_log();
    let hold_events = event_log.events_of_type("PolicyHold");

    // PolicyHold might not trigger in all cases depending on policy implementation
    // The test is to verify that IF a hold happens, the event is logged
    // If no holds, just verify no policy submit happened (transaction stayed in queue)
    if !hold_events.is_empty() {
        // Verify event details if hold occurred
        if let Some(payment_simulator_core_rs::models::Event::PolicyHold {
            tick,
            agent_id,
            tx_id: event_tx_id,
            reason,
        }) = hold_events.first()
        {
            assert_eq!(*tick, 0);
            assert_eq!(agent_id, "BANK_A");
            assert_eq!(event_tx_id, &tx_id);
            assert!(!reason.is_empty(), "Reason should be provided");
        }
    } else {
        // If no PolicyHold event, verify transaction wasn't submitted either
        let submit_events = event_log.events_for_tx(&tx_id);
        let has_submit = submit_events.iter().any(|e| matches!(
            e,
            payment_simulator_core_rs::models::Event::PolicySubmit { .. }
        ));

        // Either we have a hold event OR the transaction stays in queue (no submit)
        // This test validates that the policy makes a decision and logs it appropriately
        assert!(
            !has_submit,
            "Transaction should be held (no PolicySubmit event) when liquidity-constrained"
        );
    }
}

// ============================================================================
// Test 5: Settlement Events
// ============================================================================

#[test]
fn test_settlement_event() {
    // ARRANGE: Create orchestrator with sufficient liquidity
    let mut orchestrator = Orchestrator::new(create_test_config()).unwrap();

    // Add transaction that will settle immediately
    let tx = Transaction::new(
        "BANK_A".to_string(),
        "BANK_B".to_string(),
        100_000,
        0,
        10,
    );
    let tx_id = tx.id().to_string();

    orchestrator.state_mut().add_transaction(tx);
    orchestrator
        .state_mut()
        .get_agent_mut("BANK_A")
        .unwrap()
        .queue_outgoing(tx_id.clone());

    // ACT: Execute tick
    orchestrator.tick().unwrap();

    // ASSERT: Verify Settlement event was logged
    let event_log = orchestrator.event_log();
    let settlement_events = event_log.events_of_type("Settlement");

    assert!(
        !settlement_events.is_empty(),
        "Expected Settlement event"
    );

    // Verify event details
    let settlement = settlement_events
        .iter()
        .find(|e| {
            if let payment_simulator_core_rs::models::Event::Settlement {
                tx_id: event_tx_id,
                ..
            } = e
            {
                event_tx_id == &tx_id
            } else {
                false
            }
        })
        .expect("Should find Settlement event");

    if let payment_simulator_core_rs::models::Event::Settlement {
        tick,
        sender_id,
        receiver_id,
        amount,
        ..
    } = settlement
    {
        assert_eq!(*tick, 0);
        assert_eq!(sender_id, "BANK_A");
        assert_eq!(receiver_id, "BANK_B");
        assert_eq!(*amount, 100_000);
    }
}

// ============================================================================
// Test 6: QueuedRtgs Events
// ============================================================================

#[test]
fn test_queued_rtgs_event() {
    // ARRANGE: Create orchestrator with insufficient liquidity
    let mut config = create_test_config();
    config.agent_configs[0].opening_balance = 50_000; // Low balance
    config.agent_configs[0].unsecured_cap = 0; // No credit
    config.agent_configs[0].policy = PolicyConfig::Fifo; // Submit immediately

    let mut orchestrator = Orchestrator::new(config).unwrap();

    // Add transaction that exceeds available liquidity
    let tx = Transaction::new(
        "BANK_A".to_string(),
        "BANK_B".to_string(),
        100_000, // Exceeds balance
        0,
        10,
    );
    let tx_id = tx.id().to_string();

    orchestrator.state_mut().add_transaction(tx);
    orchestrator
        .state_mut()
        .get_agent_mut("BANK_A")
        .unwrap()
        .queue_outgoing(tx_id.clone());

    // ACT: Execute tick
    orchestrator.tick().unwrap();

    // ASSERT: Verify QueuedRtgs event was logged
    let event_log = orchestrator.event_log();
    let queued_events = event_log.events_of_type("QueuedRtgs");

    assert!(
        !queued_events.is_empty(),
        "Expected QueuedRtgs event for insufficient liquidity"
    );

    // Verify event details
    if let Some(payment_simulator_core_rs::models::Event::QueuedRtgs {
        tick,
        tx_id: event_tx_id,
        sender_id,
    }) = queued_events.first()
    {
        assert_eq!(*tick, 0);
        assert_eq!(event_tx_id, &tx_id);
        assert_eq!(sender_id, "BANK_A");
    }
}

// ============================================================================
// Test 7: CollateralPost Events
// ============================================================================

#[test]
fn test_collateral_post_event() {
    // ARRANGE: Create orchestrator with collateral management enabled
    let mut config = create_test_config();
    config.agent_configs[0].opening_balance = 50_000;
    config.agent_configs[0].unsecured_cap = 500_000; // Has credit capacity
    config.agent_configs[0].posted_collateral = Some(0); // Start with no collateral

    let mut orchestrator = Orchestrator::new(config).unwrap();

    // Add transaction that might trigger collateral posting
    let tx = Transaction::new(
        "BANK_A".to_string(),
        "BANK_B".to_string(),
        100_000,
        0,
        10,
    );
    let tx_id = tx.id().to_string();

    orchestrator.state_mut().add_transaction(tx);
    orchestrator
        .state_mut()
        .get_agent_mut("BANK_A")
        .unwrap()
        .queue_outgoing(tx_id.clone());

    // ACT: Execute multiple ticks (collateral might be posted strategically or at EOT)
    for _ in 0..5 {
        orchestrator.tick().unwrap();
    }

    // ASSERT: Check if any CollateralPost events were logged
    let event_log = orchestrator.event_log();
    let collateral_events = event_log.events_of_type("CollateralPost");

    // NOTE: This test might not always trigger collateral posting depending on policy logic
    // The test verifies that IF collateral is posted, the event is logged correctly
    if !collateral_events.is_empty() {
        if let Some(payment_simulator_core_rs::models::Event::CollateralPost {
            tick,
            agent_id,
            amount,
            reason,
            new_total,
        }) = collateral_events.first()
        {
            assert!(tick <= &4, "Event should be within simulated ticks");
            assert_eq!(agent_id, "BANK_A");
            assert!(*amount > 0, "Posted amount should be positive");
            assert!(!reason.is_empty(), "Reason should be provided");
            assert!(*new_total >= *amount, "New total should be >= posted amount");
        }
    }
}

// ============================================================================
// Test 8: EndOfDay Events
// ============================================================================

#[test]
fn test_end_of_day_event() {
    // ARRANGE: Create orchestrator for single tick past EOD
    let mut config = create_test_config();
    config.ticks_per_day = 5; // Short day for testing
    config.num_days = 1;

    let mut orchestrator = Orchestrator::new(config).unwrap();

    // ACT: Execute ticks until end of day
    for _ in 0..5 {
        orchestrator.tick().unwrap();
    }

    // ASSERT: Verify EndOfDay event was logged
    let event_log = orchestrator.event_log();
    let eod_events = event_log.events_of_type("EndOfDay");

    assert!(!eod_events.is_empty(), "Expected EndOfDay event");

    // Verify event details
    if let Some(payment_simulator_core_rs::models::Event::EndOfDay {
        tick,
        day,
        unsettled_count,
        total_penalties,
    }) = eod_events.first()
    {
        assert_eq!(*tick, 4, "EOD event should be at last tick of day");
        assert_eq!(*day, 0, "Should be day 0");
        assert!(*unsettled_count >= 0, "Unsettled count should be non-negative");
        assert!(*total_penalties >= 0, "Penalties should be non-negative");
    }
}

// ============================================================================
// Test 9: LSM Bilateral Offset Events (TDD - WILL FAIL)
// ============================================================================

#[test]
fn test_lsm_bilateral_offset_event() {
    // ARRANGE: Create 2-agent orchestrator with LOW liquidity and offsetting transactions
    let mut config = create_test_config();
    // Set low balances so transactions will queue (insufficient for RTGS)
    config.agent_configs[0].opening_balance = 50_000; // BANK_A has $500
    config.agent_configs[0].unsecured_cap = 0; // No credit
    config.agent_configs[0].policy = PolicyConfig::Fifo; // Submit immediately to RTGS

    config.agent_configs[1].opening_balance = 20_000; // BANK_B has $200
    config.agent_configs[1].unsecured_cap = 0; // No credit
    config.agent_configs[1].policy = PolicyConfig::Fifo; // Submit immediately to RTGS

    config.lsm_config.enable_bilateral = true;
    config.lsm_config.enable_cycles = true; // Enable cycles (2-agent cycles are bilateral offsets)
    config.lsm_config.max_cycle_length = 4;

    let mut orchestrator = Orchestrator::new(config).unwrap();

    // Add two offsetting transactions that exceed individual liquidity
    let tx1 = Transaction::new(
        "BANK_A".to_string(),
        "BANK_B".to_string(),
        100_000, // Exceeds BANK_A balance, will queue
        0,
        10,
    );
    let tx1_id = tx1.id().to_string();

    let tx2 = Transaction::new(
        "BANK_B".to_string(),
        "BANK_A".to_string(),
        50_000, // Exceeds BANK_B balance, will queue
        0,
        10,
    );
    let tx2_id = tx2.id().to_string();

    orchestrator.state_mut().add_transaction(tx1);
    orchestrator.state_mut().add_transaction(tx2);
    orchestrator
        .state_mut()
        .get_agent_mut("BANK_A")
        .unwrap()
        .queue_outgoing(tx1_id.clone());
    orchestrator
        .state_mut()
        .get_agent_mut("BANK_B")
        .unwrap()
        .queue_outgoing(tx2_id.clone());

    // ACT: Execute tick
    let result = orchestrator.tick().unwrap();

    // ASSERT: Verify LsmBilateralOffset event was logged
    let event_log = orchestrator.event_log();

    // Debug: Print tick result and state
    println!("\n=== Tick Result ===");
    println!("Arrivals: {}", result.num_arrivals);
    println!("Settlements: {}", result.num_settlements);
    println!("LSM Releases: {}", result.num_lsm_releases);
    println!("==================\n");

    // Debug: Print all events to see what happened
    println!("\n=== All Events ===");
    for event in event_log.events() {
        println!("{:?}", event);
    }
    println!("==================\n");

    let lsm_events = event_log.events_of_type("LsmBilateralOffset");

    assert!(
        !lsm_events.is_empty(),
        "Expected LsmBilateralOffset event. Found {} total events, {} PolicySubmit, {} Settlement",
        event_log.len(),
        event_log.events_of_type("PolicySubmit").len(),
        event_log.events_of_type("Settlement").len()
    );

    // Verify event details
    if let Some(payment_simulator_core_rs::models::Event::LsmBilateralOffset {
        tick,
        agent_a,
        agent_b,
        tx_ids,
        amount_a,
        amount_b,
    }) = lsm_events.first()
    {
        assert_eq!(*tick, 0);
        // Verify the amounts match the original transaction amounts
        // The bilateral offset settled both transactions:
        // - tx1: BANK_A → BANK_B for 100_000
        // - tx2: BANK_B → BANK_A for 50_000
        // The event records the original amounts for each transaction
        assert_eq!(tx_ids.len(), 2, "Bilateral offset should have exactly 2 transaction IDs");
        assert!(
            (agent_a == "BANK_A" && agent_b == "BANK_B"
                && tx_ids.contains(&tx1_id) && tx_ids.contains(&tx2_id)
                && *amount_a == 100_000 && *amount_b == 50_000)
            || (agent_a == "BANK_B" && agent_b == "BANK_A"
                && tx_ids.contains(&tx2_id) && tx_ids.contains(&tx1_id)
                && *amount_a == 50_000 && *amount_b == 100_000)
        );
    }
}

// ============================================================================
// Test 10: LSM Cycle Settlement Events (TDD - WILL FAIL)
// ============================================================================

#[test]
fn test_lsm_cycle_settlement_event() {
    // ARRANGE: Create 3-agent orchestrator with circular transactions
    // IMPORTANT: Use LOW balances so transactions will queue (insufficient for RTGS)
    let config = OrchestratorConfig {
        ticks_per_day: 100,
        eod_rush_threshold: 0.8,
        num_days: 1,
        rng_seed: 42,
        agent_configs: vec![
            AgentConfig {
                id: "BANK_A".to_string(),
                opening_balance: 50_000,  // $500 - less than tx amount
                unsecured_cap: 0,
                policy: PolicyConfig::Fifo,
                arrival_config: None,
                posted_collateral: None,
                collateral_haircut: None,
            },
            AgentConfig {
                id: "BANK_B".to_string(),
                opening_balance: 50_000,  // $500 - less than tx amount
                unsecured_cap: 0,
                policy: PolicyConfig::Fifo,
                arrival_config: None,
                posted_collateral: None,
                collateral_haircut: None,
            },
            AgentConfig {
                id: "BANK_C".to_string(),
                opening_balance: 50_000,  // $500 - less than tx amount
                unsecured_cap: 0,
                policy: PolicyConfig::Fifo,
                arrival_config: None,
                posted_collateral: None,
                collateral_haircut: None,
            },
        ],
        cost_rates: CostRates::default(),
        lsm_config: LsmConfig {
            enable_bilateral: true,
            enable_cycles: true,
            max_cycle_length: 4,
            max_cycles_per_tick: 10,
        },
        scenario_events: None,
    };

    let mut orchestrator = Orchestrator::new(config).unwrap();

    // Create cycle: A→B→C→A (each tx exceeds individual agent balance)
    let tx1 = Transaction::new("BANK_A".to_string(), "BANK_B".to_string(), 100_000, 0, 10);
    let tx2 = Transaction::new("BANK_B".to_string(), "BANK_C".to_string(), 100_000, 0, 10);
    let tx3 = Transaction::new("BANK_C".to_string(), "BANK_A".to_string(), 100_000, 0, 10);

    let tx1_id = tx1.id().to_string();
    let tx2_id = tx2.id().to_string();
    let tx3_id = tx3.id().to_string();

    orchestrator.state_mut().add_transaction(tx1);
    orchestrator.state_mut().add_transaction(tx2);
    orchestrator.state_mut().add_transaction(tx3);

    orchestrator
        .state_mut()
        .get_agent_mut("BANK_A")
        .unwrap()
        .queue_outgoing(tx1_id.clone());
    orchestrator
        .state_mut()
        .get_agent_mut("BANK_B")
        .unwrap()
        .queue_outgoing(tx2_id.clone());
    orchestrator
        .state_mut()
        .get_agent_mut("BANK_C")
        .unwrap()
        .queue_outgoing(tx3_id.clone());

    // ACT: Execute tick
    orchestrator.tick().unwrap();

    // ASSERT: Verify LsmCycleSettlement event was logged
    let event_log = orchestrator.event_log();
    let lsm_cycle_events = event_log.events_of_type("LsmCycleSettlement");

    assert!(
        !lsm_cycle_events.is_empty(),
        "Expected LsmCycleSettlement event for 3-agent cycle"
    );

    // Verify event details
    if let Some(payment_simulator_core_rs::models::Event::LsmCycleSettlement {
        tick,
        tx_ids,
        total_value,
        ..
    }) = lsm_cycle_events.first()
    {
        assert_eq!(*tick, 0);
        assert_eq!(tx_ids.len(), 3, "Cycle should involve 3 transactions");
        assert_eq!(*total_value, 300_000, "Cycle value should be sum of all transactions (T2-compliant): 3 × 100k = 300k");
        assert!(tx_ids.contains(&tx1_id));
        assert!(tx_ids.contains(&tx2_id));
        assert!(tx_ids.contains(&tx3_id));
    }
}

// ============================================================================
// Test 11: Event Ordering and Completeness
// ============================================================================

#[test]
fn test_event_log_ordering_and_completeness() {
    // ARRANGE: Create orchestrator and run multiple ticks
    let mut orchestrator = Orchestrator::new(create_test_config()).unwrap();

    // Add several transactions
    for i in 0..3 {
        let tx = Transaction::new(
            "BANK_A".to_string(),
            "BANK_B".to_string(),
            100_000,
            i,
            i + 10,
        );
        let tx_id = tx.id().to_string();

        orchestrator.state_mut().add_transaction(tx);
        orchestrator
            .state_mut()
            .get_agent_mut("BANK_A")
            .unwrap()
            .queue_outgoing(tx_id);
    }

    // ACT: Execute multiple ticks
    for _ in 0..5 {
        orchestrator.tick().unwrap();
    }

    // ASSERT: Verify event log structure
    let event_log = orchestrator.event_log();

    // Should have events
    assert!(!event_log.is_empty(), "Event log should not be empty");

    // Events should be ordered by tick
    let events = event_log.events();
    for i in 1..events.len() {
        assert!(
            events[i].tick() >= events[i - 1].tick(),
            "Events should be ordered by tick"
        );
    }

    // Should have multiple event types
    let event_types: std::collections::HashSet<&str> =
        events.iter().map(|e| e.event_type()).collect();
    assert!(
        event_types.len() >= 2,
        "Should have multiple event types (got: {:?})",
        event_types
    );

    // Every arrival should have corresponding policy decision
    let arrivals = event_log.events_of_type("Arrival");
    for arrival in arrivals {
        if let payment_simulator_core_rs::models::Event::Arrival { tx_id, .. } = arrival {
            let tx_events = event_log.events_for_tx(tx_id);
            assert!(
                tx_events.len() >= 2,
                "Transaction {} should have arrival + at least one policy event",
                tx_id
            );
        }
    }
}
